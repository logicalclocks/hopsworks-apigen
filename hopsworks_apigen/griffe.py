#
#   Copyright 2026 Hopsworks AB
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#

from __future__ import annotations

from typing import Any

import griffe


logger = griffe.get_logger(__name__)


class HopsworksApigenGriffe(griffe.Extension):
    # The comment serves both as a warning and as a marker for deletion of the file during scans.
    MAGIC_COMMENT = (
        "# This file is generated by hopsworks-apigen.\n"
        "# Do not edit it manually!\n"
        "# It is managed by hopsworks-apigen and is subject to periodical deletion.\n"
    )

    def __init__(self, object_paths: list[str] | None = None) -> None:
        self.object_paths = object_paths

    def on_class(
        self, *, cls: griffe.Class, loader: griffe.GriffeLoader, **kwargs: Any
    ) -> None:
        self._on_decoratable(cls)

    def on_function(
        self, *, func: griffe.Function, loader: griffe.GriffeLoader, **kwargs: Any
    ) -> None:
        self._on_decoratable(func)

    def _on_decoratable(self, decoratable: griffe.Class | griffe.Function):
        decoratable.public = False

        if decoratable.is_alias:
            return

        if not hasattr(decoratable, "decorators") or not decoratable.decorators:
            return

        decoratable.extra["hopsworks_apigen"] = {
            "is_public": False,
            "aliases": [],
            "deprecated": None,
            "order": 0,
        }

        # Parse @deprecated
        deprecated = [
            decorator
            for decorator in decoratable.decorators
            if decorator.callable_path == "hopsworks_apigen.deprecated"
        ]
        if deprecated:
            decoratable.extra["hopsworks_apigen"]["deprecated"] = (
                _parse_deprecated_decorator(deprecated[0])
            )
            if len(deprecated) > 1:
                logger.warning(
                    f"Multiple @deprecated decorators found on {decoratable.path}; only the first one is considered."
                )

        # Parse @public
        publics = [
            decorator
            for decorator in decoratable.decorators
            if decorator.callable_path == "hopsworks_apigen.public"
        ]
        if publics:
            decoratable.extra["hopsworks_apigen"]["is_public"] = True
            decoratable.public = True
            paths, order = _extract_public_info(publics[0])
            decoratable.extra["hopsworks_apigen"]["order"] = order
            for target_module, alias_name in _parse_paths(paths):
                decoratable.extra["hopsworks_apigen"]["aliases"].append(
                    {
                        "target_module": target_module,
                        "alias_name": alias_name,
                        "from_module": decoratable.module.path,
                        "object_name": decoratable.name,
                        "is_public": True,
                    }
                )
            if len(publics) > 1:
                logger.warning(
                    f"Multiple @public decorators found on {decoratable.path}; only the first one is considered."
                )

        # Parse @also_available_as
        also_available = [
            decorator
            for decorator in decoratable.decorators
            if decorator.callable_path == "hopsworks_apigen.also_available_as"
        ]
        if also_available:
            paths = _extract_paths(also_available[0])
            paths = [
                f"{decoratable.module.path}.{decoratable.name}" if p == "" else p
                for p in paths
            ]
            for target_module, alias_name in _parse_paths(paths):
                decoratable.extra["hopsworks_apigen"]["aliases"].append(
                    {
                        "target_module": target_module,
                        "alias_name": alias_name,
                        "from_module": decoratable.module.path,
                        "object_name": decoratable.name,
                        "is_public": False,
                    }
                )
            if len(also_available) > 1:
                logger.warning(
                    f"Multiple @also_available_as decorators found on {decoratable.path}; only the first one is considered."
                )


def _extract_paths(decorator) -> list[str]:
    """Parse a @public or @also_available_as decorator and extract paths.

    Returns list of path strings.
    """
    # @public without arguments (bare decorator)
    if not isinstance(decorator.value, griffe.ExprCall):
        return []

    expr = decorator.value

    # Extract positional arguments (paths)
    paths = []
    for arg in expr.arguments:
        if isinstance(arg, str):
            paths.append(arg.strip("'\""))

    return paths


def _extract_public_info(decorator) -> tuple[list[str], int]:
    """Parse a @public decorator and extract paths and order.

    Returns (paths, order) tuple.
    """
    # @public without arguments (bare decorator)
    if not isinstance(decorator.value, griffe.ExprCall):
        return [], 0

    expr = decorator.value

    # Extract positional arguments (paths)
    paths = []
    for arg in expr.arguments:
        if isinstance(arg, str):
            paths.append(arg.strip("'\""))

    # Extract order keyword argument
    order = 0
    for arg in expr.arguments:
        if (
            isinstance(arg, griffe.ExprKeyword)
            and arg.name == "order"
            and isinstance(arg.value, (int, str))
        ):
            order = int(arg.value) if isinstance(arg.value, str) else arg.value

    return paths, order


def _parse_paths(paths: list[str]) -> list[tuple[str, str]]:
    """Expand path strings into (target_module, alias_name) tuples."""
    result = []
    for path in paths:
        # Split "module.path.name" into module and name
        parts = path.rsplit(".", 1)
        if len(parts) == 1:
            # Just a name, no module - use empty string for root
            result.append(("", parts[0]))
        else:
            result.append((parts[0], parts[1]))
    return result


def _parse_deprecated_decorator(decorator) -> dict:
    """Parse a @deprecated decorator call.

    Returns dict with 'deprecated_by' (list) and 'available_until' (str | None).
    """
    if not isinstance(decorator.value, griffe.ExprCall):
        return {"deprecated_by": [], "available_until": None}

    expr = decorator.value

    # Extract positional arguments (deprecated_by)
    deprecated_by = []
    for arg in expr.arguments:
        if isinstance(arg, str):
            deprecated_by.append(arg.strip("'\""))

    # Extract available_until keyword argument
    available_until = None
    for arg in expr.arguments:
        if (
            isinstance(arg, griffe.ExprKeyword)
            and arg.name == "available_until"
            and isinstance(arg.value, str)
        ):
            available_until = arg.value.strip("'\"")

    return {
        "deprecated_by": deprecated_by,
        "available_until": available_until,
    }
